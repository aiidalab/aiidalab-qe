from aiida.orm import WorkChainNode

FUNCTIONAL_LINK_MAP = {
    "PBE": "https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.3865",
    "PBEsol": "https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.100.136406",
}

PSEUDO_LINK_MAP = {
    "SSSP": "https://www.materialscloud.org/discover/sssp/table/efficiency"
}

PROTOCOL_PSEUDO_MAP = {
    "fast": "SSSP/1.2/PBE/efficiency",
    "moderate": "SSSP/1.2/PBE/efficiency",
    "precise": "SSSP/1.2/PBE/precision",
}

FUNCTIONAL_REPORT_MAP = {
    "LDA": "local density approximation (LDA)",
    "PBE": "generalized gradient approximation of Perdew-Burke-Ernzerhof (PBE)",
    "PBEsol": "the revised generalized gradient approximation of Perdew-Burke-Ernzerhof (PBE) for solids",
}


def _generate_report_dict(builder_parameters: dict):
    """Read from the bulider parameters and generate a dictionacry
    for reporting the inputs for the `QeAppWorkChain` with proper name corresponding
    to the template.
    """
    # Workflow logic
    yield "relax_method", builder_parameters["relax_type"]
    yield "relaxed", builder_parameters["run_relax"]
    yield "bands_computed", builder_parameters["run_bands"]
    yield "pdos_computed", builder_parameters["run_pdos"]

    # Material settings
    yield "material_magnetic", builder_parameters["spin_type"]
    yield "electronic_type", builder_parameters["electronic_type"]

    # Calculation settings
    yield "protocol", builder_parameters["protocol"]

    # Pseudopotential settings
    yield "pseudo_family", builder_parameters["pseudo_family"]
    yield "pseudo_version", builder_parameters["pseudo_version"]
    yield "pseudo_protocol", builder_parameters["pseudo_protocol"]

    pseudo_library = builder_parameters["pseudo_library"]
    functional = builder_parameters["functional"]
    yield "pseudo_library", pseudo_library
    yield "functional", functional

    yield "pseudo_link", PSEUDO_LINK_MAP[pseudo_library]
    yield "functional_link", FUNCTIONAL_LINK_MAP[functional]

    # Detail calculation parameters
    yield "energy_cutoff_wfc", builder_parameters["energy_cutoff_wfc"]
    yield "energy_cutoff_rho", builder_parameters["energy_cutoff_rho"]
    yield "scf_kpoints_distance", builder_parameters["scf_kpoints_distance"]
    yield "bands_kpoints_distance", builder_parameters["bands_kpoints_distance"]
    yield "nscf_kpoints_distance", builder_parameters["nscf_kpoints_distance"]

    occupation = builder_parameters["occupation"]
    yield "occupation_type", occupation

    if occupation == "smearing":
        yield "degauss", builder_parameters["degauss"]
        yield "smearing", builder_parameters["smearing"]

    yield "tot_charge", builder_parameters["tot_charge"]
    yield "initial_magnetic_moments", builder_parameters["initial_magnetic_moments"]
    yield "hubbard", builder_parameters["hubbard"]
    yield "spin_orbit", builder_parameters["spin_orbit"]
    yield "periodicity", builder_parameters["periodicity"]


def _generate_report_html(report):
    """Read from the bulider parameters and generate a html for reporting
    the inputs for the `QeAppWorkChain`.
    """
    from importlib import resources

    from jinja2 import Environment

    from aiidalab_qe.app import static

    def _fmt_yes_no(truthy):
        return "Yes" if truthy else "No"

    env = Environment()
    env.filters.update(
        {
            "fmt_yes_no": _fmt_yes_no,
        }
    )
    template = resources.read_text(static, "workflow_summary.jinja")
    style = resources.read_text(static, "style.css")

    return env.from_string(template).render(style=style, **report)


def generate_report_html(qeapp_wc):
    """Generate a html for reporting the inputs for the `QeAppWorkChain`"""
    builder_parameters = qeapp_wc.base.extras.get("builder_parameters", {})
    report = dict(_generate_report_dict(builder_parameters))

    return _generate_report_html(report)


def generate_report_text(report_dict):
    """Generate a text for reporting the inputs for the `QeAppWorkChain`

    :param report_dict: dictionary generated by the `generate_report_dict` function.
    """

    report_string = (
        "All calculations are performed within the density-functional "
        "theory formalism as implemented in the Quantum ESPRESSO code. "
        "The pseudopotential for each element is extracted from the "
        f'{report_dict["Pseudopotential library"][0]} '
        "library. The wave functions "
        "of the valence electrons are expanded in a plane wave basis set, using an "
        "energy cutoff equal to "
        f'{round(report_dict["Plane wave energy cutoff (wave functions)"][0])} Ry '
        "for the wave functions and "
        f'{round(report_dict["Plane wave energy cutoff (charge density)"][0])} Ry '
        "for the charge density and potential. "
        "The exchange-correlation energy is "
        "calculated using the "
        f'{FUNCTIONAL_REPORT_MAP[report_dict["Functional"][0]]}. '
        "A Monkhorst-Pack mesh is used for sampling the Brillouin zone, where the "
        "distance between the k-points is set to "
    )
    kpoints_distances = []
    kpoints_calculations = []

    for calc in ("SCF", "NSCF", "Bands"):
        if f"K-point mesh distance ({calc})" in report_dict:
            kpoints_distances.append(
                str(report_dict[f"K-point mesh distance ({calc})"][0])
            )
            kpoints_calculations.append(calc)

    report_string += ", ".join(kpoints_distances)
    report_string += " for the "
    report_string += ", ".join(kpoints_calculations)
    report_string += " calculation"
    if len(kpoints_distances) > 1:
        report_string += "s, respectively"
    report_string += "."

    return report_string


def get_hubbard_occupations_list(qeapp_wc: WorkChainNode) -> list:
    """Get the occupations dictionary for the Hubbard U calculation.

    :param qeapp_wc: `QeAppWorkChain` instance.
    :returns: list of dictionaries of Hubbard occupations.
    """
    builder_parameters = qeapp_wc.base.extras.get(
        "builder_parameters", {}
    )  # To know from where to get the occupations!
    workchain = qeapp_wc.called[-1]

    initial_pattern = "HUBBARD OCCUPATIONS"
    end_pattern = "Number of occupied Hubbard levels ="
    list_string = []
    with workchain.called[0].outputs.retrieved.base.repository.open(
        "aiida.out", "r"
    ) as file:
        file_contents = file.readlines()
        i = 0
        while i < len(file_contents):
            if initial_pattern in file_contents[i]:
                i += 1
                text = ""
                while i < len(file_contents) and end_pattern not in file_contents[i]:
                    text += file_contents[i]
                    i += 1
                if text:
                    list_string.append(text)
            else:
                i += 1

    last_text = list_string[-1]
    lines = last_text.splitlines()

    eigenvalues_tot = []
    occupation_matrix_tot = []
    eigenvalues_up = []
    eigenvalues_down = []
    occupation_matrix_up = []
    occupation_matrix_down = []
    magnetic_moment = []  # magneton/bohr
    atom_index = []
    trace_occupation = []
    spin_flag = None

    for index, line in enumerate(lines):
        if "Tr[ns" in line:
            line_temp = line.split()
            if builder_parameters["spin_type"] == "none":
                trace_occupation.append([line_temp[-1]])
            else:
                trace_occupation.append([line_temp[-3], line_temp[-2], line_temp[-1]])
        elif "ATOM" in line:
            atom_index.append(line.split()[-2])
        elif "Atomic magnetic moment" in line:
            magnetic_moment.append(line.split()[-1])
            # atom_index.append(line.split()[-3])
        elif "SPIN  1" in line:
            spin_flag = "up"
        elif "SPIN  2" in line:
            spin_flag = "down"
        elif "eigenvalues:" in line:
            eigenvalues = lines[index + 1]
            eigenvalues_tot.append(eigenvalues)
            if spin_flag == "up":
                eigenvalues_up.append(eigenvalues)
            elif spin_flag == "down":
                eigenvalues_down.append(eigenvalues)
        elif "occupation matrix ns" in line:
            matrix_lines = len(lines[index + 1].split())
            occupation_matrix = lines[index + 1 : index + matrix_lines + 1]
            occupation_matrix_tot.append(occupation_matrix)
            if spin_flag == "up":
                occupation_matrix_up.append(occupation_matrix)
            elif spin_flag == "down":
                occupation_matrix_down.append(occupation_matrix)

    if builder_parameters["spin_type"] != "none":
        keys = [
            "atom_index",
            "magnetic_moment",
            "eigenvalues_up",
            "eigenvalues_down",
            "occupation_matrix_up",
            "occupation_matrix_down",
            "trace_occupation",
        ]
        tuple_list = list(
            zip(
                atom_index,
                magnetic_moment,
                eigenvalues_up,
                eigenvalues_down,
                occupation_matrix_up,
                occupation_matrix_down,
                trace_occupation,
            )
        )
        occupations = [dict(zip(keys, values)) for values in tuple_list]
    else:
        keys = [
            "atom_index",
            "eigenvalues_tot",
            "occupation_matrix_tot",
            "trace_occupation",
        ]
        tuple_list = list(
            zip(atom_index, eigenvalues_tot, occupation_matrix_tot, trace_occupation)
        )
        occupations = [dict(zip(keys, values)) for values in tuple_list]

    return occupations
