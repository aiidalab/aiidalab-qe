import pytest


@pytest.mark.usefixtures("sssp")
def test_create_builder_default(
    data_regression,
    submit_app_generator,
):
    """ "Test the creation of the workchain builder.

    metal, non-magnetic
    """

    app = submit_app_generator(properties=["bands", "pdos"])
    submit_step = app.submit_step

    submit_step._create_builder()
    # since uuid is specific to each run, we remove it from the output
    ui_parameters = remove_uuid_fields(submit_step.ui_parameters)
    # regression test for the parameters generated by the app
    # this parameters are passed to the workchain
    data_regression.check(ui_parameters)
    # test if create builder successfully
    submit_step._create_builder()
    # In the future, we will check the builder parameters using regresion test


@pytest.mark.usefixtures("sssp")
def test_create_process_label(
    submit_app_generator,
):
    """ "Test the creation of the correct process label"""

    app = submit_app_generator(properties=["bands", "pdos"])
    submit_step = app.submit_step
    submit_step._update_process_label()
    assert (
        submit_step.process_label.value
        == "Si2 [relax: atoms+cell, moderate protocol] → bands, pdos"
    )
    # suppose we change the label of the structure:
    submit_step.input_structure.label = "Si2, unit cell"
    submit_step._update_process_label()
    assert (
        submit_step.process_label.value
        == "Si2, unit cell [relax: atoms+cell, moderate protocol] → bands, pdos"
    )
    # suppose by mistake we provide an empty label, we then fallback to use the formula:
    submit_step.input_structure.label = ""
    submit_step._update_process_label()
    assert (
        submit_step.process_label.value
        == "Si2 [relax: atoms+cell, moderate protocol] → bands, pdos"
    )


@pytest.mark.usefixtures("sssp")
def test_create_builder_insulator(
    submit_app_generator,
):
    """ "Test the creation of the workchain builder.

    insulator, non-magnetic, no smearing
    the occupation type is set to fixed, smearing and degauss should not be set"""

    app = submit_app_generator(
        electronic_type="insulator", properties=["bands", "pdos"]
    )
    submit_step = app.submit_step

    builder = submit_step._create_builder()

    # check and validate the builder
    got = builder_to_readable_dict(builder)

    assert (
        got["bands"]["bands"]["scf"]["pw"]["parameters"]["SYSTEM"]["occupations"]
        == "fixed"
    )
    assert "smearing" not in got["bands"]["bands"]["scf"]["pw"]["parameters"]["SYSTEM"]


@pytest.mark.usefixtures("sssp")
def test_create_builder_advanced_settings(
    submit_app_generator,
):
    """Test the creation of the workchain builder with advanced settings

    -metal
    -collinear
    -tot_charge
    -initial_magnetic_moments
    -vdw_corr
    -electron_maxstep
    -properties: bands, pdos
    """

    app = submit_app_generator(
        electronic_type="metal",
        spin_type="collinear",
        tot_charge=1.0,
        vdw_corr="dft-d3bj",
        initial_magnetic_moments=0.1,
        electron_maxstep=100,
        properties=["bands", "pdos"],
    )
    submit_step = app.submit_step

    builder = submit_step._create_builder()

    # check and validate the builder
    got = builder_to_readable_dict(builder)

    # test tot_charge is updated in the three steps
    for parameters in [
        got["relax"]["base"],
        got["bands"]["bands"]["scf"],
        got["pdos"]["scf"],
        got["pdos"]["nscf"],
    ]:
        assert parameters["pw"]["parameters"]["SYSTEM"]["tot_charge"] == 1.0
        assert parameters["pw"]["parameters"]["SYSTEM"]["vdw_corr"] == "dft-d3"
        assert parameters["pw"]["parameters"]["SYSTEM"]["dftd3_version"] == 4
        assert parameters["pw"]["parameters"]["ELECTRONS"]["electron_maxstep"] == 100

    # test initial_magnetic_moments set 'starting_magnetization' in pw.in
    assert (
        got["relax"]["base"]["pw"]["parameters"]["SYSTEM"]["starting_magnetization"][
            "Si"
        ]
        == 0.025
    )


@pytest.mark.usefixtures("sssp")
def test_warning_messages(
    generate_structure_data,
    submit_app_generator,
):
    """Test the creation of the warning messages.

    For now, we test that the suggestions are indeed there.
    We should check the whole message, but this is for now not easy to do: the message is built
    on the fly with variables which are not accessible in this namespace.
    """
    import os

    suggestions = {
        "more_resources": "<li>Increase the resources (CPUs should be equal or more than 4, if possible) </li>",
        "change_configuration": "<li>Review the configuration (e.g. choosing <i>fast protocol</i> - this will affect precision) </li>",
        "go_remote": "<li>Select a code that runs on a larger machine</li>",
        "avoid_overloading": "<li>Reduce the number of CPUs to avoid the overloading of the local machine </li>",
    }
    app = submit_app_generator(properties=["bands", "pdos"])
    submit_step = app.submit_step
    submit_step.codes["pw"].num_cpus.value = 1
    submit_step._check_resources()
    # no warning:
    assert submit_step._submission_warning_messages.value == ""

    # now we increase the resources, so we should have the Warning-3
    submit_step.codes["pw"].num_cpus.value = len(os.sched_getaffinity(0))
    submit_step._check_resources()
    for suggestion in ["avoid_overloading", "go_remote"]:
        assert suggestions[suggestion] in submit_step._submission_warning_messages.value

    # now we use a large structure, so we should have the Warning-1 (and 2 if not on localhost)
    structure = generate_structure_data("H2O-larger")
    submit_step.input_structure = structure
    submit_step.codes["pw"].num_cpus.value = 1
    submit_step._check_resources()
    for suggestion in ["more_resources", "change_configuration"]:
        assert suggestions[suggestion] in submit_step._submission_warning_messages.value


def builder_to_readable_dict(builder):
    """transverse the builder and return a dictionary with readable values."""
    from aiida import orm
    from aiida.engine import ProcessBuilderNamespace
    from aiida.plugins import DataFactory

    UpfData = DataFactory("pseudo.upf")

    ignore_keys = ["metadata", "monitors", "code", "structure"]

    readable_dict = {}
    for k, v in builder.items():
        if k in ignore_keys:
            continue
        if isinstance(v, UpfData):
            readable_dict[k] = v.filename
        elif isinstance(v, (dict, ProcessBuilderNamespace)):
            readable_dict[k] = builder_to_readable_dict(v)
        elif isinstance(v, orm.Dict):
            readable_dict[k] = v.get_dict()
        elif isinstance(v, (orm.Int, orm.Float, orm.Str, orm.Bool)):
            readable_dict[k] = v.value
        elif isinstance(v, orm.List):
            readable_dict[k] = v.get_list()
        else:
            readable_dict[k] = v

    return readable_dict


def remove_uuid_fields(data):
    """
    Recursively remove fields that contain UUID values from a dictionary.

    :param data: The dictionary to process.
    :return: The dictionary with UUID fields removed.
    """
    import re

    # Define a UUID pattern
    uuid_pattern = re.compile(
        r"[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}", re.I
    )

    if isinstance(data, dict):
        new_dict = {}
        for key, value in data.items():
            # If the value matches the UUID pattern, skip adding it to the new dictionary
            if isinstance(value, str) and uuid_pattern.match(value):
                continue
            # Otherwise, process the value recursively and add it to the new dictionary
            else:
                new_dict[key] = remove_uuid_fields(value)
        return new_dict
    elif isinstance(data, list):
        # Process each item in the list recursively
        return [remove_uuid_fields(item) for item in data]
    else:
        # Return the value unchanged if it's not a dictionary or list
        return data
