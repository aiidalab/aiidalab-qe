import pytest


@pytest.mark.usefixtures("sssp")
def test_create_builder_default(
    data_regression,
    submit_app_generator,
):
    """ "Test the creation of the workchain builder.

    metal, non-magnetic
    """

    app = submit_app_generator(properties=["bands", "pdos"])
    submit_step = app.submit_step

    submit_step._create_builder()
    # since uuid is specific to each run, we remove it from the output
    ui_parameters = remove_uuid_fields(submit_step.ui_parameters)
    # regression test for the parameters generated by the app
    # this parameters are passed to the workchain
    data_regression.check(ui_parameters)
    # test if create builder successfully
    submit_step._create_builder()
    # In the future, we will check the builder parameters using regresion test


@pytest.mark.usefixtures("sssp")
def test_create_process_label(
    submit_app_generator,
):
    """ "Test the creation of the correct process label"""

    app = submit_app_generator(properties=["bands", "pdos"])
    submit_step = app.submit_step
    submit_step._update_process_label()
    assert (
        submit_step.process_label.value
        == "Si2 [relax: atoms+cell, moderate protocol] → bands, pdos"
    )
    # suppose we change the label of the structure:
    submit_step.input_structure.label = "Si2, unit cell"
    submit_step._update_process_label()
    assert (
        submit_step.process_label.value
        == "Si2, unit cell [relax: atoms+cell, moderate protocol] → bands, pdos"
    )
    # suppose by mistake we provide an empty label, we then fallback to use the formula:
    submit_step.input_structure.label = ""
    submit_step._update_process_label()
    assert (
        submit_step.process_label.value
        == "Si2 [relax: atoms+cell, moderate protocol] → bands, pdos"
    )


@pytest.mark.usefixtures("sssp")
def test_create_builder_insulator(
    submit_app_generator,
):
    """ "Test the creation of the workchain builder.

    insulator, non-magnetic, no smearing
    the occupation type is set to fixed, smearing and degauss should not be set"""

    app = submit_app_generator(
        electronic_type="insulator", properties=["bands", "pdos"]
    )
    submit_step = app.submit_step

    builder = submit_step._create_builder()

    # check and validate the builder
    got = builder_to_readable_dict(builder)

    assert (
        got["bands"]["bands"]["scf"]["pw"]["parameters"]["SYSTEM"]["occupations"]
        == "fixed"
    )
    assert "smearing" not in got["bands"]["bands"]["scf"]["pw"]["parameters"]["SYSTEM"]


@pytest.mark.usefixtures("sssp")
def test_create_builder_advanced_settings(
    submit_app_generator,
):
    """Test the creation of the workchain builder with advanced settings

    -metal
    -collinear
    -tot_charge
    -initial_magnetic_moments
    -vdw_corr
    -electron_maxstep
    -properties: bands, pdos
    """

    app = submit_app_generator(
        electronic_type="metal",
        spin_type="collinear",
        tot_charge=1.0,
        vdw_corr="dft-d3bj",
        initial_magnetic_moments=0.1,
        electron_maxstep=100,
        properties=["bands", "pdos"],
    )
    submit_step = app.submit_step

    builder = submit_step._create_builder()

    # check and validate the builder
    got = builder_to_readable_dict(builder)

    # test tot_charge is updated in the three steps
    for parameters in [
        got["relax"]["base"],
        got["bands"]["bands"]["scf"],
        got["pdos"]["scf"],
        got["pdos"]["nscf"],
    ]:
        assert parameters["pw"]["parameters"]["SYSTEM"]["tot_charge"] == 1.0
        assert parameters["pw"]["parameters"]["SYSTEM"]["vdw_corr"] == "dft-d3"
        assert parameters["pw"]["parameters"]["SYSTEM"]["dftd3_version"] == 4
        assert parameters["pw"]["parameters"]["ELECTRONS"]["electron_maxstep"] == 100

    # test initial_magnetic_moments set 'starting_magnetization' in pw.in
    assert (
        got["relax"]["base"]["pw"]["parameters"]["SYSTEM"]["starting_magnetization"][
            "Si"
        ]
        == 0.025
    )


@pytest.mark.usefixtures("sssp")
def test_warning_messages(
    generate_structure_data,
    submit_app_generator,
):
    """ "Test the creation of the workchain builder.

    metal, non-magnetic
    """

    app = submit_app_generator(properties=["bands", "pdos"])
    submit_step = app.submit_step
    submit_step.codes["pw"].num_cpus.value = 1
    submit_step._check_resources()
    # no warning:
    assert submit_step._submission_warning_messages.value == ""

    # now we increase the resources, so we should have the Warning-3
    submit_step.codes["pw"].num_cpus.value = 8
    submit_step._check_resources()
    message = (
        "<span>&#9888;</span> Warning: the selected pw.x code will run on the local host, but "
        "the number of CPUs is larger than one. Please be sure that your local "
        "environment has enough free CPUs for the calculation. Consider the following: "
        "<ul>"
        "<li>Consider to reduce the number of CPUs to avoid the overloading of the local machine "
        "<li>Select a code that runs on a larger machine </li>"
        "</ul>"
    )
    assert (
        submit_step._submission_warning_messages.value
        == submit_step._ALERT_MESSAGE.format(alert_class="warning", message=message)
    )

    # now we use a large structure, so we should have the Warning-1 (and 2 if not on localhost)
    structure = generate_structure_data("H2O-larger")
    submit_step.input_structure = structure
    num_sites, volume = len(structure.sites), structure.get_cell_volume()
    submit_step.codes["pw"].num_cpus.value = 1
    submit_step._check_resources()
    message = (
        f"<span>&#9888;</span> Warning: The selected structure has a large number of atoms ({num_sites}) "
        f"or a significant cell volume ({int(volume)} Å<sup>3</sup>), making it computationally demanding "
        "to run in a reasonable amount of time. Consider the following: "
        "<ul>"
        "<li>Select a code that runs on a larger machine</li>"
        "<li>Increase the resources (CPUs should be equal or more than 4, if possible)</li>"
        "<li>Consider to review the configuration (e.g. choosing <i>fast protocol</i> - this will affect precision) "
        "</ul>"
    )
    assert (
        submit_step._submission_warning_messages.value
        == submit_step._ALERT_MESSAGE.format(alert_class="warning", message=message)
    )


def builder_to_readable_dict(builder):
    """transverse the builder and return a dictionary with readable values."""
    from aiida import orm
    from aiida.engine import ProcessBuilderNamespace
    from aiida.plugins import DataFactory

    UpfData = DataFactory("pseudo.upf")

    ignore_keys = ["metadata", "monitors", "code", "structure"]

    readable_dict = {}
    for k, v in builder.items():
        if k in ignore_keys:
            continue
        if isinstance(v, UpfData):
            readable_dict[k] = v.filename
        elif isinstance(v, (dict, ProcessBuilderNamespace)):
            readable_dict[k] = builder_to_readable_dict(v)
        elif isinstance(v, orm.Dict):
            readable_dict[k] = v.get_dict()
        elif isinstance(v, (orm.Int, orm.Float, orm.Str, orm.Bool)):
            readable_dict[k] = v.value
        elif isinstance(v, orm.List):
            readable_dict[k] = v.get_list()
        else:
            readable_dict[k] = v

    return readable_dict


def remove_uuid_fields(data):
    """
    Recursively remove fields that contain UUID values from a dictionary.

    :param data: The dictionary to process.
    :return: The dictionary with UUID fields removed.
    """
    import re

    # Define a UUID pattern
    uuid_pattern = re.compile(
        r"[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}", re.I
    )

    if isinstance(data, dict):
        new_dict = {}
        for key, value in data.items():
            # If the value matches the UUID pattern, skip adding it to the new dictionary
            if isinstance(value, str) and uuid_pattern.match(value):
                continue
            # Otherwise, process the value recursively and add it to the new dictionary
            else:
                new_dict[key] = remove_uuid_fields(value)
        return new_dict
    elif isinstance(data, list):
        # Process each item in the list recursively
        return [remove_uuid_fields(item) for item in data]
    else:
        # Return the value unchanged if it's not a dictionary or list
        return data
